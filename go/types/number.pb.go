// Code generated by protoc-gen-go. DO NOT EDIT.
// source: types/number.proto

package types

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Possible behaviours for values that are not allowed by the number
type InvalidNumberBehaviour int32

const (
	// A default behaviour will be applied, typically RESTRICT
	InvalidNumberBehaviour_UNSPECIFIED InvalidNumberBehaviour = 0
	// The value will be restricted to the most appropriate value, typically the closest
	InvalidNumberBehaviour_RESTRICT InvalidNumberBehaviour = 1
	// An error will be raised to alert to the invalid value
	InvalidNumberBehaviour_ERROR InvalidNumberBehaviour = 2
	// Ignore the bounds and apply the value anyway
	InvalidNumberBehaviour_ALLOW InvalidNumberBehaviour = 3
)

var InvalidNumberBehaviour_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "RESTRICT",
	2: "ERROR",
	3: "ALLOW",
}

var InvalidNumberBehaviour_value = map[string]int32{
	"UNSPECIFIED": 0,
	"RESTRICT":    1,
	"ERROR":       2,
	"ALLOW":       3,
}

func (x InvalidNumberBehaviour) String() string {
	return proto.EnumName(InvalidNumberBehaviour_name, int32(x))
}

func (InvalidNumberBehaviour) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{0}
}

// Options for how invalid number values will be handled
type NumberCapping struct {
	// If the value is less than the minimum, behave this way. Should default to RESTRICT
	Min InvalidNumberBehaviour `protobuf:"varint,1,opt,name=min,proto3,enum=smartcore.api.types.InvalidNumberBehaviour" json:"min,omitempty"`
	// If the value does not lie on a step value, behave this way. Should default to ALLOW
	Step InvalidNumberBehaviour `protobuf:"varint,2,opt,name=step,proto3,enum=smartcore.api.types.InvalidNumberBehaviour" json:"step,omitempty"`
	// If the value is greater than the maximum, behave this way. Should default to RESTRICT
	Max                  InvalidNumberBehaviour `protobuf:"varint,3,opt,name=max,proto3,enum=smartcore.api.types.InvalidNumberBehaviour" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *NumberCapping) Reset()         { *m = NumberCapping{} }
func (m *NumberCapping) String() string { return proto.CompactTextString(m) }
func (*NumberCapping) ProtoMessage()    {}
func (*NumberCapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{0}
}

func (m *NumberCapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NumberCapping.Unmarshal(m, b)
}
func (m *NumberCapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NumberCapping.Marshal(b, m, deterministic)
}
func (m *NumberCapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberCapping.Merge(m, src)
}
func (m *NumberCapping) XXX_Size() int {
	return xxx_messageInfo_NumberCapping.Size(m)
}
func (m *NumberCapping) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberCapping.DiscardUnknown(m)
}

var xxx_messageInfo_NumberCapping proto.InternalMessageInfo

func (m *NumberCapping) GetMin() InvalidNumberBehaviour {
	if m != nil {
		return m.Min
	}
	return InvalidNumberBehaviour_UNSPECIFIED
}

func (m *NumberCapping) GetStep() InvalidNumberBehaviour {
	if m != nil {
		return m.Step
	}
	return InvalidNumberBehaviour_UNSPECIFIED
}

func (m *NumberCapping) GetMax() InvalidNumberBehaviour {
	if m != nil {
		return m.Max
	}
	return InvalidNumberBehaviour_UNSPECIFIED
}

// Defines the bounds for a number. Either of the min or max values can be absent which means those aspects are
// unbounded. It makes no sense for both to be unset, if so then this is no longer a bounds but that isn't
// disallowed.
//
// Contrary to most programming practices both min and max are inclusive and denote the max allowed value, just like
// htmls input type=range.
type Int32Bounds struct {
	// the minimum value (inclusive). If absent then there is no minimum, though this is typically Int32.Min
	Min *wrappers.Int32Value `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	// the maximum value (inclusive). If absent then there is no maximum, though this is typically Int32.Max
	Max                  *wrappers.Int32Value `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Int32Bounds) Reset()         { *m = Int32Bounds{} }
func (m *Int32Bounds) String() string { return proto.CompactTextString(m) }
func (*Int32Bounds) ProtoMessage()    {}
func (*Int32Bounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{1}
}

func (m *Int32Bounds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Int32Bounds.Unmarshal(m, b)
}
func (m *Int32Bounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Int32Bounds.Marshal(b, m, deterministic)
}
func (m *Int32Bounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32Bounds.Merge(m, src)
}
func (m *Int32Bounds) XXX_Size() int {
	return xxx_messageInfo_Int32Bounds.Size(m)
}
func (m *Int32Bounds) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32Bounds.DiscardUnknown(m)
}

var xxx_messageInfo_Int32Bounds proto.InternalMessageInfo

func (m *Int32Bounds) GetMin() *wrappers.Int32Value {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *Int32Bounds) GetMax() *wrappers.Int32Value {
	if m != nil {
		return m.Max
	}
	return nil
}

// Describes a numerical value. Can describe the current value or be used for updates.
//
// When ramp is provided, the target_value is used as the end goal of the transition, if value is also provided then
// this will be treated as a transition between value and target_value. If no value is present in this case then the
// current value of the number will be used creating a transition from current to target_value.
type Int32Var struct {
	// The numbers current value if known. Typically one of value or target_value will be set
	Value *wrappers.Int32Value `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Optional. Indicates the current progress through a transition. If present then target_value may be set. When
	// writing a value this denotes the intended tween duration.
	Ramp *Tween `protobuf:"bytes,2,opt,name=ramp,proto3" json:"ramp,omitempty"`
	// If ramping, then defines the value that we are ramping towards
	TargetValue          *wrappers.Int32Value `protobuf:"bytes,3,opt,name=target_value,json=targetValue,proto3" json:"target_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Int32Var) Reset()         { *m = Int32Var{} }
func (m *Int32Var) String() string { return proto.CompactTextString(m) }
func (*Int32Var) ProtoMessage()    {}
func (*Int32Var) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{2}
}

func (m *Int32Var) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Int32Var.Unmarshal(m, b)
}
func (m *Int32Var) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Int32Var.Marshal(b, m, deterministic)
}
func (m *Int32Var) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32Var.Merge(m, src)
}
func (m *Int32Var) XXX_Size() int {
	return xxx_messageInfo_Int32Var.Size(m)
}
func (m *Int32Var) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32Var.DiscardUnknown(m)
}

var xxx_messageInfo_Int32Var proto.InternalMessageInfo

func (m *Int32Var) GetValue() *wrappers.Int32Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Int32Var) GetRamp() *Tween {
	if m != nil {
		return m.Ramp
	}
	return nil
}

func (m *Int32Var) GetTargetValue() *wrappers.Int32Value {
	if m != nil {
		return m.TargetValue
	}
	return nil
}

// Describes features and restrictions applied to a number that is typically used as part of an apis value
type Int32Attributes struct {
	Bounds *Int32Bounds `protobuf:"bytes,1,opt,name=bounds,proto3" json:"bounds,omitempty"`
	// The stepping interval, how little the value can change in one go. A default value of 0 is equivalent to a
	// continuous step, i.e. step=1
	Step int32 `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
	// Indicate whether the device supports delta adjustments when changing the value
	SupportsDelta bool `protobuf:"varint,4,opt,name=supports_delta,json=supportsDelta,proto3" json:"supports_delta,omitempty"`
	// Indicate the level of ramp support the device has
	RampSupport TweenSupport `protobuf:"varint,5,opt,name=ramp_support,json=rampSupport,proto3,enum=smartcore.api.types.TweenSupport" json:"ramp_support,omitempty"`
	// Provide information on how invalid values will be handled
	DefaultCapping       *NumberCapping `protobuf:"bytes,6,opt,name=default_capping,json=defaultCapping,proto3" json:"default_capping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Int32Attributes) Reset()         { *m = Int32Attributes{} }
func (m *Int32Attributes) String() string { return proto.CompactTextString(m) }
func (*Int32Attributes) ProtoMessage()    {}
func (*Int32Attributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{3}
}

func (m *Int32Attributes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Int32Attributes.Unmarshal(m, b)
}
func (m *Int32Attributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Int32Attributes.Marshal(b, m, deterministic)
}
func (m *Int32Attributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32Attributes.Merge(m, src)
}
func (m *Int32Attributes) XXX_Size() int {
	return xxx_messageInfo_Int32Attributes.Size(m)
}
func (m *Int32Attributes) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32Attributes.DiscardUnknown(m)
}

var xxx_messageInfo_Int32Attributes proto.InternalMessageInfo

func (m *Int32Attributes) GetBounds() *Int32Bounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *Int32Attributes) GetStep() int32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *Int32Attributes) GetSupportsDelta() bool {
	if m != nil {
		return m.SupportsDelta
	}
	return false
}

func (m *Int32Attributes) GetRampSupport() TweenSupport {
	if m != nil {
		return m.RampSupport
	}
	return TweenSupport_NO_SUPPORT
}

func (m *Int32Attributes) GetDefaultCapping() *NumberCapping {
	if m != nil {
		return m.DefaultCapping
	}
	return nil
}

// Defines the bounds for a number. Either of the min or max values can be absent which means those aspects are
// unbounded. It makes no sense for both to be unset, if so then this is no longer a bounds but that isn't
// disallowed.
//
// Contrary to most programming practices both min and max are inclusive and denote the max allowed value, just like
// htmls input type=range.
type FloatBounds struct {
	// the minimum value (inclusive). If absent then there is no minimum, though this is typically Float.Min
	Min *wrappers.FloatValue `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	// the maximum value (inclusive). If absent then there is no maximum, though this is typically Float.Max
	Max                  *wrappers.FloatValue `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FloatBounds) Reset()         { *m = FloatBounds{} }
func (m *FloatBounds) String() string { return proto.CompactTextString(m) }
func (*FloatBounds) ProtoMessage()    {}
func (*FloatBounds) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{4}
}

func (m *FloatBounds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FloatBounds.Unmarshal(m, b)
}
func (m *FloatBounds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatBounds.Marshal(b, m, deterministic)
}
func (m *FloatBounds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatBounds.Merge(m, src)
}
func (m *FloatBounds) XXX_Size() int {
	return xxx_messageInfo_FloatBounds.Size(m)
}
func (m *FloatBounds) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatBounds.DiscardUnknown(m)
}

var xxx_messageInfo_FloatBounds proto.InternalMessageInfo

func (m *FloatBounds) GetMin() *wrappers.FloatValue {
	if m != nil {
		return m.Min
	}
	return nil
}

func (m *FloatBounds) GetMax() *wrappers.FloatValue {
	if m != nil {
		return m.Max
	}
	return nil
}

// Describes a numerical value. Can describe the current value or be used for updates.
//
// When ramp is provided, the target_value is used as the end goal of the transition, if value is also provided then
// this will be treated as a transition between value and target_value. If no value is present in this case then the
// current value of the number will be used creating a transition from current to target_value.
type FloatVar struct {
	// The numbers current value if known. Typically one of value or target_value will be set
	Value *wrappers.FloatValue `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Optional. Indicates the current progress through a transition. If present then target_value may be set. When
	// writing a value this denotes the intended tween duration.
	Ramp *Tween `protobuf:"bytes,2,opt,name=ramp,proto3" json:"ramp,omitempty"`
	// If ramping, then defines the value that we are ramping towards
	TargetValue          *wrappers.FloatValue `protobuf:"bytes,3,opt,name=target_value,json=targetValue,proto3" json:"target_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *FloatVar) Reset()         { *m = FloatVar{} }
func (m *FloatVar) String() string { return proto.CompactTextString(m) }
func (*FloatVar) ProtoMessage()    {}
func (*FloatVar) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{5}
}

func (m *FloatVar) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FloatVar.Unmarshal(m, b)
}
func (m *FloatVar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatVar.Marshal(b, m, deterministic)
}
func (m *FloatVar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatVar.Merge(m, src)
}
func (m *FloatVar) XXX_Size() int {
	return xxx_messageInfo_FloatVar.Size(m)
}
func (m *FloatVar) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatVar.DiscardUnknown(m)
}

var xxx_messageInfo_FloatVar proto.InternalMessageInfo

func (m *FloatVar) GetValue() *wrappers.FloatValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *FloatVar) GetRamp() *Tween {
	if m != nil {
		return m.Ramp
	}
	return nil
}

func (m *FloatVar) GetTargetValue() *wrappers.FloatValue {
	if m != nil {
		return m.TargetValue
	}
	return nil
}

// Describes features and restrictions applied to a number that is typically used as part of an apis value
type FloatAttributes struct {
	Bounds *FloatBounds `protobuf:"bytes,1,opt,name=bounds,proto3" json:"bounds,omitempty"`
	// The stepping interval, how little the value can change in one go. A default value of 0 is equivalent to a
	// continuous step, i.e. all possible float values are supported
	Step float32 `protobuf:"fixed32,3,opt,name=step,proto3" json:"step,omitempty"`
	// Indicate whether the device supports delta adjustments when changing the value
	SupportsDelta bool `protobuf:"varint,4,opt,name=supports_delta,json=supportsDelta,proto3" json:"supports_delta,omitempty"`
	// Indicate the level of ramp support the device has
	RampSupport TweenSupport `protobuf:"varint,5,opt,name=ramp_support,json=rampSupport,proto3,enum=smartcore.api.types.TweenSupport" json:"ramp_support,omitempty"`
	// Provide information on how invalid values will be handled
	DefaultCapping       *NumberCapping `protobuf:"bytes,6,opt,name=default_capping,json=defaultCapping,proto3" json:"default_capping,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FloatAttributes) Reset()         { *m = FloatAttributes{} }
func (m *FloatAttributes) String() string { return proto.CompactTextString(m) }
func (*FloatAttributes) ProtoMessage()    {}
func (*FloatAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_1898d41abe3910da, []int{6}
}

func (m *FloatAttributes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FloatAttributes.Unmarshal(m, b)
}
func (m *FloatAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatAttributes.Marshal(b, m, deterministic)
}
func (m *FloatAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatAttributes.Merge(m, src)
}
func (m *FloatAttributes) XXX_Size() int {
	return xxx_messageInfo_FloatAttributes.Size(m)
}
func (m *FloatAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_FloatAttributes proto.InternalMessageInfo

func (m *FloatAttributes) GetBounds() *FloatBounds {
	if m != nil {
		return m.Bounds
	}
	return nil
}

func (m *FloatAttributes) GetStep() float32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *FloatAttributes) GetSupportsDelta() bool {
	if m != nil {
		return m.SupportsDelta
	}
	return false
}

func (m *FloatAttributes) GetRampSupport() TweenSupport {
	if m != nil {
		return m.RampSupport
	}
	return TweenSupport_NO_SUPPORT
}

func (m *FloatAttributes) GetDefaultCapping() *NumberCapping {
	if m != nil {
		return m.DefaultCapping
	}
	return nil
}

func init() {
	proto.RegisterEnum("smartcore.api.types.InvalidNumberBehaviour", InvalidNumberBehaviour_name, InvalidNumberBehaviour_value)
	proto.RegisterType((*NumberCapping)(nil), "smartcore.api.types.NumberCapping")
	proto.RegisterType((*Int32Bounds)(nil), "smartcore.api.types.Int32Bounds")
	proto.RegisterType((*Int32Var)(nil), "smartcore.api.types.Int32Var")
	proto.RegisterType((*Int32Attributes)(nil), "smartcore.api.types.Int32Attributes")
	proto.RegisterType((*FloatBounds)(nil), "smartcore.api.types.FloatBounds")
	proto.RegisterType((*FloatVar)(nil), "smartcore.api.types.FloatVar")
	proto.RegisterType((*FloatAttributes)(nil), "smartcore.api.types.FloatAttributes")
}

func init() { proto.RegisterFile("types/number.proto", fileDescriptor_1898d41abe3910da) }

var fileDescriptor_1898d41abe3910da = []byte{
	// 560 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x54, 0xdd, 0x6a, 0x13, 0x41,
	0x18, 0x75, 0x37, 0x4d, 0xa9, 0xb3, 0x69, 0x12, 0xa7, 0xa0, 0x4b, 0x04, 0x89, 0x01, 0xa1, 0x2a,
	0x99, 0xc5, 0xf4, 0xc6, 0x1b, 0x95, 0xfc, 0x15, 0x82, 0xb5, 0x0d, 0x9b, 0xa8, 0xe0, 0x4d, 0x98,
	0x24, 0xd3, 0x75, 0xe8, 0x66, 0x67, 0x98, 0x9d, 0x4d, 0xe3, 0xa3, 0xf8, 0x0a, 0x82, 0xaf, 0xe2,
	0x33, 0xc9, 0xfc, 0x34, 0xa6, 0xb8, 0xc5, 0x54, 0xf0, 0xc2, 0xbb, 0x9d, 0x6f, 0xce, 0x99, 0xf3,
	0x7d, 0xe7, 0x3b, 0x2c, 0x80, 0xf2, 0x0b, 0x27, 0x69, 0x90, 0x64, 0x8b, 0x29, 0x11, 0x88, 0x0b,
	0x26, 0x19, 0x3c, 0x48, 0x17, 0x58, 0xc8, 0x19, 0x13, 0x04, 0x61, 0x4e, 0x91, 0x46, 0xd4, 0x1e,
	0x45, 0x8c, 0x45, 0x31, 0x09, 0x34, 0x64, 0x9a, 0x9d, 0x07, 0x97, 0x02, 0x73, 0x4e, 0x44, 0x6a,
	0x48, 0xb5, 0x7b, 0xe6, 0x21, 0x79, 0x49, 0x48, 0x62, 0x4a, 0x8d, 0x1f, 0x0e, 0xd8, 0x3f, 0xd5,
	0x0f, 0x77, 0x31, 0xe7, 0x34, 0x89, 0xe0, 0x2b, 0x50, 0x58, 0xd0, 0xc4, 0x77, 0xea, 0xce, 0x61,
	0xb9, 0xf5, 0x1c, 0xe5, 0xe8, 0xa0, 0x41, 0xb2, 0xc4, 0x31, 0x9d, 0x1b, 0x5e, 0x87, 0x7c, 0xc6,
	0x4b, 0xca, 0x32, 0x11, 0x2a, 0x1e, 0x7c, 0x03, 0x76, 0x52, 0x49, 0xb8, 0xef, 0xde, 0x9e, 0xaf,
	0x89, 0x5a, 0x1f, 0xaf, 0xfc, 0xc2, 0xdf, 0xe8, 0xe3, 0x55, 0xe3, 0x02, 0x78, 0x83, 0x44, 0x1e,
	0xb5, 0x3a, 0x2c, 0x4b, 0xe6, 0x29, 0x6c, 0xfe, 0x9a, 0xc6, 0x6b, 0x3d, 0x44, 0xc6, 0x20, 0x74,
	0x65, 0x10, 0xd2, 0xd0, 0x0f, 0x38, 0xce, 0x88, 0xe9, 0xbe, 0x69, 0xc4, 0xdd, 0x6d, 0xe0, 0x78,
	0xd5, 0xf8, 0xee, 0x80, 0x3d, 0x5b, 0x13, 0xf0, 0x05, 0x28, 0x2e, 0xd5, 0xd5, 0x36, 0x62, 0x06,
	0x09, 0x11, 0xd8, 0x11, 0x78, 0xc1, 0xad, 0x5e, 0x2d, 0x77, 0xd8, 0xb1, 0xda, 0x56, 0xa8, 0x71,
	0xf0, 0x35, 0x28, 0x49, 0x2c, 0x22, 0x22, 0x27, 0x46, 0xa9, 0xf0, 0x67, 0x25, 0xcf, 0x10, 0xf4,
	0xa1, 0xf1, 0xd5, 0x05, 0x15, 0x7d, 0xd7, 0x96, 0x52, 0xd0, 0x69, 0x26, 0x49, 0x0a, 0x5f, 0x82,
	0xdd, 0xa9, 0xf6, 0xca, 0xf6, 0x5d, 0xbf, 0xc1, 0xf2, 0xb5, 0xa7, 0xa1, 0xc5, 0x43, 0x68, 0x57,
	0xad, 0xba, 0x28, 0xda, 0xed, 0x3d, 0x01, 0xe5, 0x34, 0xe3, 0x9c, 0x09, 0x99, 0x4e, 0xe6, 0x24,
	0x96, 0xd8, 0xdf, 0xa9, 0x3b, 0x87, 0x7b, 0xe1, 0xfe, 0x55, 0xb5, 0xa7, 0x8a, 0xb0, 0x07, 0x4a,
	0x6a, 0xa0, 0x89, 0xad, 0xfa, 0x45, 0xbd, 0xed, 0xc7, 0x37, 0x1b, 0x30, 0x32, 0xc0, 0xd0, 0x53,
	0x34, 0x7b, 0x80, 0x6f, 0x41, 0x65, 0x4e, 0xce, 0x71, 0x16, 0xcb, 0xc9, 0xcc, 0xa4, 0xd7, 0xdf,
	0xd5, 0x33, 0x34, 0x72, 0x1f, 0xba, 0x96, 0xf3, 0xb0, 0x6c, 0xa9, 0xf6, 0xac, 0x82, 0x73, 0x1c,
	0x33, 0x2c, 0xb7, 0x0b, 0x8e, 0x86, 0x6e, 0x1f, 0x9c, 0x6b, 0x70, 0x1b, 0x1c, 0x5b, 0xdb, 0x22,
	0x38, 0x1b, 0xec, 0x7f, 0x1c, 0x9c, 0x0d, 0xa5, 0xdf, 0x82, 0xa3, 0xef, 0x6e, 0x1d, 0x9c, 0x0d,
	0x4f, 0x73, 0x83, 0xe3, 0xfe, 0xef, 0xc1, 0x79, 0xf6, 0x0e, 0xdc, 0xcf, 0xff, 0x21, 0xc1, 0x0a,
	0xf0, 0xde, 0x9f, 0x8e, 0x86, 0xfd, 0xee, 0xe0, 0x78, 0xd0, 0xef, 0x55, 0xef, 0xc0, 0x12, 0xd8,
	0x0b, 0xfb, 0xa3, 0x71, 0x38, 0xe8, 0x8e, 0xab, 0x0e, 0xbc, 0x0b, 0x8a, 0xfd, 0x30, 0x3c, 0x0b,
	0xab, 0xae, 0xfa, 0x6c, 0x9f, 0x9c, 0x9c, 0x7d, 0xac, 0x16, 0x3a, 0x14, 0x3c, 0x98, 0x93, 0x65,
	0x5e, 0x1f, 0x1d, 0xcf, 0x08, 0x0c, 0xd5, 0xb6, 0x86, 0xce, 0xa7, 0xa7, 0x11, 0x95, 0x68, 0x89,
	0x13, 0x49, 0xd1, 0x8c, 0xa1, 0xec, 0x22, 0x58, 0x73, 0x82, 0x74, 0xd6, 0xc4, 0x9c, 0x06, 0x11,
	0x0b, 0x34, 0xf3, 0x9b, 0x7b, 0x30, 0x5a, 0xbf, 0xd7, 0xe6, 0x14, 0x8d, 0x55, 0x75, 0xba, 0xab,
	0xf7, 0x7e, 0xf4, 0x33, 0x00, 0x00, 0xff, 0xff, 0x89, 0xc0, 0x5b, 0x6b, 0x61, 0x06, 0x00, 0x00,
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: device/traits/input_select.proto

package traits

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// possible modes an input select device can
type InputSelectFeature int32

const (
	// both audio and video are treated as one. independent_av should be considered false in this mode
	InputSelectFeature_AV InputSelectFeature = 0
	// Only audio inputs are supported
	InputSelectFeature_AUDIO_ONLY InputSelectFeature = 1
	// Only video inputs are supported
	InputSelectFeature_VIDEO_ONLY InputSelectFeature = 2
	// Audio and video are both supported and can be selected independently if desired. The independent_av property can
	// be true in this mode only
	InputSelectFeature_INDEPENDENT InputSelectFeature = 3
)

var InputSelectFeature_name = map[int32]string{
	0: "AV",
	1: "AUDIO_ONLY",
	2: "VIDEO_ONLY",
	3: "INDEPENDENT",
}

var InputSelectFeature_value = map[string]int32{
	"AV":          0,
	"AUDIO_ONLY":  1,
	"VIDEO_ONLY":  2,
	"INDEPENDENT": 3,
}

func (x InputSelectFeature) String() string {
	return proto.EnumName(InputSelectFeature_name, int32(x))
}

func (InputSelectFeature) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{0}
}

// Trait.attributes relating to the input select device
type InputSelectAttributes struct {
	// the list of inputs that can be selected on this device
	Inputs []*AvPort `protobuf:"bytes,1,rep,name=inputs,proto3" json:"inputs,omitempty"`
	// indicate the possible mode of input selection that are supported by this device. This is not the current mode, just
	// the supported mode the device allows
	SupportedFeature InputSelectFeature `protobuf:"varint,2,opt,name=supported_feature,json=supportedFeature,proto3,enum=smartcore.api.device.traits.InputSelectFeature" json:"supported_feature,omitempty"`
	// The list of outputs that can have inputs on this device
	Outputs              []*AvPort `protobuf:"bytes,3,rep,name=outputs,proto3" json:"outputs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *InputSelectAttributes) Reset()         { *m = InputSelectAttributes{} }
func (m *InputSelectAttributes) String() string { return proto.CompactTextString(m) }
func (*InputSelectAttributes) ProtoMessage()    {}
func (*InputSelectAttributes) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{0}
}

func (m *InputSelectAttributes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InputSelectAttributes.Unmarshal(m, b)
}
func (m *InputSelectAttributes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InputSelectAttributes.Marshal(b, m, deterministic)
}
func (m *InputSelectAttributes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputSelectAttributes.Merge(m, src)
}
func (m *InputSelectAttributes) XXX_Size() int {
	return xxx_messageInfo_InputSelectAttributes.Size(m)
}
func (m *InputSelectAttributes) XXX_DiscardUnknown() {
	xxx_messageInfo_InputSelectAttributes.DiscardUnknown(m)
}

var xxx_messageInfo_InputSelectAttributes proto.InternalMessageInfo

func (m *InputSelectAttributes) GetInputs() []*AvPort {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *InputSelectAttributes) GetSupportedFeature() InputSelectFeature {
	if m != nil {
		return m.SupportedFeature
	}
	return InputSelectFeature_AV
}

func (m *InputSelectAttributes) GetOutputs() []*AvPort {
	if m != nil {
		return m.Outputs
	}
	return nil
}

// represents a source (or destination) for the AV signal
type AvPort struct {
	// Unique name for the port, used as the value for input or output properties
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Official human readable name for this port
	Title       string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// If this port supports different features from the device as a whole, specify them here. For example some ports
	// might be audio only or not support audio breakout
	SupportedFeature     InputSelectFeature `protobuf:"varint,4,opt,name=supported_feature,json=supportedFeature,proto3,enum=smartcore.api.device.traits.InputSelectFeature" json:"supported_feature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *AvPort) Reset()         { *m = AvPort{} }
func (m *AvPort) String() string { return proto.CompactTextString(m) }
func (*AvPort) ProtoMessage()    {}
func (*AvPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{1}
}

func (m *AvPort) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AvPort.Unmarshal(m, b)
}
func (m *AvPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AvPort.Marshal(b, m, deterministic)
}
func (m *AvPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvPort.Merge(m, src)
}
func (m *AvPort) XXX_Size() int {
	return xxx_messageInfo_AvPort.Size(m)
}
func (m *AvPort) XXX_DiscardUnknown() {
	xxx_messageInfo_AvPort.DiscardUnknown(m)
}

var xxx_messageInfo_AvPort proto.InternalMessageInfo

func (m *AvPort) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AvPort) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AvPort) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *AvPort) GetSupportedFeature() InputSelectFeature {
	if m != nil {
		return m.SupportedFeature
	}
	return InputSelectFeature_AV
}

// The currently selected input
type Input struct {
	// The current choice for the video input. Will be absent if there is no video input chosen.
	VideoInput string `protobuf:"bytes,1,opt,name=video_input,json=videoInput,proto3" json:"video_input,omitempty"`
	// The current choice for the audio input. Absent means no audio input is chosen unless independent_av is false which
	// implies the audio_input is the same as the video_input
	AudioInput string `protobuf:"bytes,2,opt,name=audio_input,json=audioInput,proto3" json:"audio_input,omitempty"`
	// If true then audio and video changes will not affect the other. False implies that changes to audio or video will
	// change the input selection for the other to keep them consistent
	IndependentAv bool `protobuf:"varint,3,opt,name=independent_av,json=independentAv,proto3" json:"independent_av,omitempty"`
	// Which output the input is sent to. Optional when the device only has one output, required otherwise
	Output               string   `protobuf:"bytes,4,opt,name=output,proto3" json:"output,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Input) Reset()         { *m = Input{} }
func (m *Input) String() string { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()    {}
func (*Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{2}
}

func (m *Input) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Input.Unmarshal(m, b)
}
func (m *Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Input.Marshal(b, m, deterministic)
}
func (m *Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Input.Merge(m, src)
}
func (m *Input) XXX_Size() int {
	return xxx_messageInfo_Input.Size(m)
}
func (m *Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Input proto.InternalMessageInfo

func (m *Input) GetVideoInput() string {
	if m != nil {
		return m.VideoInput
	}
	return ""
}

func (m *Input) GetAudioInput() string {
	if m != nil {
		return m.AudioInput
	}
	return ""
}

func (m *Input) GetIndependentAv() bool {
	if m != nil {
		return m.IndependentAv
	}
	return false
}

func (m *Input) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// A request to update the current input
type UpdateInputRequest struct {
	// The name of the device to update
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The new input value
	Input *Input `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// the fields we are intending to update. Paths are relative to the input not this request
	UpdateMask           *field_mask.FieldMask `protobuf:"bytes,3,opt,name=update_mask,json=updateMask,proto3" json:"update_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UpdateInputRequest) Reset()         { *m = UpdateInputRequest{} }
func (m *UpdateInputRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateInputRequest) ProtoMessage()    {}
func (*UpdateInputRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{3}
}

func (m *UpdateInputRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateInputRequest.Unmarshal(m, b)
}
func (m *UpdateInputRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateInputRequest.Marshal(b, m, deterministic)
}
func (m *UpdateInputRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateInputRequest.Merge(m, src)
}
func (m *UpdateInputRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateInputRequest.Size(m)
}
func (m *UpdateInputRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateInputRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateInputRequest proto.InternalMessageInfo

func (m *UpdateInputRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateInputRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *UpdateInputRequest) GetUpdateMask() *field_mask.FieldMask {
	if m != nil {
		return m.UpdateMask
	}
	return nil
}

// A request to get the currently selected input
type GetInputRequest struct {
	// The name of the device to get the value for
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Required if the device has multiple outputs. The name of the output to get the input for.
	Output               string   `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetInputRequest) Reset()         { *m = GetInputRequest{} }
func (m *GetInputRequest) String() string { return proto.CompactTextString(m) }
func (*GetInputRequest) ProtoMessage()    {}
func (*GetInputRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{4}
}

func (m *GetInputRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetInputRequest.Unmarshal(m, b)
}
func (m *GetInputRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetInputRequest.Marshal(b, m, deterministic)
}
func (m *GetInputRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInputRequest.Merge(m, src)
}
func (m *GetInputRequest) XXX_Size() int {
	return xxx_messageInfo_GetInputRequest.Size(m)
}
func (m *GetInputRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInputRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInputRequest proto.InternalMessageInfo

func (m *GetInputRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetInputRequest) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// Request to begin a subscription for selected input changes
type PullInputRequest struct {
	// The name of the device we want events from
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PullInputRequest) Reset()         { *m = PullInputRequest{} }
func (m *PullInputRequest) String() string { return proto.CompactTextString(m) }
func (*PullInputRequest) ProtoMessage()    {}
func (*PullInputRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{5}
}

func (m *PullInputRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PullInputRequest.Unmarshal(m, b)
}
func (m *PullInputRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PullInputRequest.Marshal(b, m, deterministic)
}
func (m *PullInputRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullInputRequest.Merge(m, src)
}
func (m *PullInputRequest) XXX_Size() int {
	return xxx_messageInfo_PullInputRequest.Size(m)
}
func (m *PullInputRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PullInputRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PullInputRequest proto.InternalMessageInfo

func (m *PullInputRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// A response as part of the stream of changes to the selected input
type PullInputResponse struct {
	// The list of changes
	Changes              []*InputChange `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *PullInputResponse) Reset()         { *m = PullInputResponse{} }
func (m *PullInputResponse) String() string { return proto.CompactTextString(m) }
func (*PullInputResponse) ProtoMessage()    {}
func (*PullInputResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{6}
}

func (m *PullInputResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PullInputResponse.Unmarshal(m, b)
}
func (m *PullInputResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PullInputResponse.Marshal(b, m, deterministic)
}
func (m *PullInputResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullInputResponse.Merge(m, src)
}
func (m *PullInputResponse) XXX_Size() int {
	return xxx_messageInfo_PullInputResponse.Size(m)
}
func (m *PullInputResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PullInputResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PullInputResponse proto.InternalMessageInfo

func (m *PullInputResponse) GetChanges() []*InputChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

// A change to a single devices range value
type InputChange struct {
	// name for the device that issued the change
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// when the change occurred
	CreateTime *timestamp.Timestamp `protobuf:"bytes,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// The new value for the selected input
	Input                *Input   `protobuf:"bytes,3,opt,name=input,proto3" json:"input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InputChange) Reset()         { *m = InputChange{} }
func (m *InputChange) String() string { return proto.CompactTextString(m) }
func (*InputChange) ProtoMessage()    {}
func (*InputChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b879f56057430263, []int{7}
}

func (m *InputChange) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InputChange.Unmarshal(m, b)
}
func (m *InputChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InputChange.Marshal(b, m, deterministic)
}
func (m *InputChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputChange.Merge(m, src)
}
func (m *InputChange) XXX_Size() int {
	return xxx_messageInfo_InputChange.Size(m)
}
func (m *InputChange) XXX_DiscardUnknown() {
	xxx_messageInfo_InputChange.DiscardUnknown(m)
}

var xxx_messageInfo_InputChange proto.InternalMessageInfo

func (m *InputChange) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *InputChange) GetCreateTime() *timestamp.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *InputChange) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func init() {
	proto.RegisterEnum("smartcore.api.device.traits.InputSelectFeature", InputSelectFeature_name, InputSelectFeature_value)
	proto.RegisterType((*InputSelectAttributes)(nil), "smartcore.api.device.traits.InputSelectAttributes")
	proto.RegisterType((*AvPort)(nil), "smartcore.api.device.traits.AvPort")
	proto.RegisterType((*Input)(nil), "smartcore.api.device.traits.Input")
	proto.RegisterType((*UpdateInputRequest)(nil), "smartcore.api.device.traits.UpdateInputRequest")
	proto.RegisterType((*GetInputRequest)(nil), "smartcore.api.device.traits.GetInputRequest")
	proto.RegisterType((*PullInputRequest)(nil), "smartcore.api.device.traits.PullInputRequest")
	proto.RegisterType((*PullInputResponse)(nil), "smartcore.api.device.traits.PullInputResponse")
	proto.RegisterType((*InputChange)(nil), "smartcore.api.device.traits.InputChange")
}

func init() { proto.RegisterFile("device/traits/input_select.proto", fileDescriptor_b879f56057430263) }

var fileDescriptor_b879f56057430263 = []byte{
	// 689 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xc5, 0x49, 0x9b, 0x36, 0xd7, 0xa2, 0x4d, 0x47, 0x80, 0xa2, 0x74, 0xd1, 0xc8, 0x08, 0x14,
	0x21, 0x3a, 0x86, 0xb0, 0x41, 0xaa, 0xba, 0x70, 0x49, 0x8a, 0x22, 0xd1, 0x34, 0x72, 0x1f, 0x08,
	0x14, 0x29, 0x9a, 0xd8, 0xd3, 0x30, 0xaa, 0x63, 0x1b, 0xcf, 0xd8, 0xdf, 0xc0, 0x27, 0xb0, 0x63,
	0xc3, 0x8a, 0x25, 0x7b, 0x7e, 0x80, 0xbf, 0xe1, 0x0f, 0x90, 0x67, 0xec, 0xd4, 0x7d, 0x28, 0x09,
	0x12, 0xbb, 0xcc, 0xbd, 0xe7, 0xdc, 0x39, 0xe7, 0xfa, 0x8c, 0x02, 0x4d, 0x97, 0x26, 0xcc, 0xa1,
	0xa6, 0x88, 0x08, 0x13, 0xdc, 0x64, 0x7e, 0x18, 0x8b, 0x11, 0xa7, 0x1e, 0x75, 0x04, 0x0e, 0xa3,
	0x40, 0x04, 0x68, 0x9b, 0x4f, 0x49, 0x24, 0x9c, 0x20, 0xa2, 0x98, 0x84, 0x0c, 0x2b, 0x3c, 0x56,
	0xf8, 0x46, 0x73, 0x12, 0x04, 0x13, 0x8f, 0x9a, 0x12, 0x3a, 0x8e, 0x2f, 0xcc, 0x0b, 0x46, 0x3d,
	0x77, 0x34, 0x25, 0xfc, 0x52, 0xd1, 0x1b, 0x3b, 0x37, 0x11, 0x82, 0x4d, 0x29, 0x17, 0x64, 0x1a,
	0x2a, 0x80, 0xf1, 0x47, 0x83, 0x87, 0xbd, 0xf4, 0xda, 0x13, 0x79, 0xab, 0x25, 0x44, 0xc4, 0xc6,
	0xb1, 0xa0, 0x1c, 0xed, 0x41, 0x45, 0xea, 0xe1, 0x75, 0xad, 0x59, 0x6e, 0xe9, 0xed, 0xc7, 0x78,
	0x8e, 0x14, 0x6c, 0x25, 0x83, 0x20, 0x12, 0x76, 0x46, 0x41, 0x43, 0xd8, 0xe2, 0x71, 0x18, 0x06,
	0x91, 0xa0, 0xee, 0xe8, 0x82, 0x12, 0x11, 0x47, 0xb4, 0x5e, 0x6a, 0x6a, 0xad, 0x8d, 0xb6, 0x39,
	0x77, 0x4e, 0x41, 0xcb, 0xa1, 0xa2, 0xd9, 0xb5, 0xd9, 0xa4, 0xac, 0x82, 0xf6, 0x61, 0x2d, 0x88,
	0x85, 0xd4, 0x56, 0x5e, 0x5e, 0x5b, 0xce, 0x31, 0x7e, 0x6a, 0x50, 0x51, 0x35, 0x84, 0x60, 0xc5,
	0x27, 0x53, 0x5a, 0xd7, 0x9a, 0x5a, 0xab, 0x6a, 0xcb, 0xdf, 0xe8, 0x01, 0xac, 0x0a, 0x26, 0x3c,
	0xa5, 0xb7, 0x6a, 0xab, 0x03, 0x6a, 0x82, 0xee, 0x52, 0xee, 0x44, 0x2c, 0x14, 0x2c, 0xf0, 0xeb,
	0x65, 0xd9, 0x2b, 0x96, 0xee, 0xf6, 0xbc, 0xf2, 0x9f, 0x3c, 0x1b, 0x5f, 0x34, 0x58, 0x95, 0x40,
	0xb4, 0x03, 0x7a, 0xc2, 0x5c, 0x1a, 0x8c, 0xe4, 0xae, 0x33, 0xe9, 0x20, 0x4b, 0x33, 0x00, 0x89,
	0x5d, 0x96, 0x03, 0x94, 0x0d, 0x90, 0x25, 0x05, 0x78, 0x02, 0x1b, 0xcc, 0x77, 0x69, 0x48, 0x7d,
	0x97, 0xfa, 0x62, 0x44, 0x12, 0x69, 0x67, 0xdd, 0xbe, 0x5f, 0xa8, 0x5a, 0x09, 0x7a, 0x04, 0x15,
	0xb5, 0x32, 0xe9, 0xa2, 0x6a, 0x67, 0x27, 0xe3, 0x9b, 0x06, 0xe8, 0x2c, 0x74, 0x89, 0xa0, 0x72,
	0x9c, 0x4d, 0x3f, 0xc7, 0x94, 0xdf, 0xbd, 0xcb, 0xd7, 0xb0, 0x7a, 0x25, 0x42, 0x6f, 0x1b, 0x8b,
	0xf7, 0x60, 0x2b, 0x02, 0xda, 0x03, 0x3d, 0x96, 0x77, 0xc8, 0x38, 0x4b, 0x81, 0x7a, 0xbb, 0x81,
	0x55, 0x9e, 0x71, 0x9e, 0x67, 0x7c, 0x98, 0x26, 0xfe, 0x88, 0xf0, 0x4b, 0x1b, 0x14, 0x3c, 0xfd,
	0x6d, 0xec, 0xc3, 0xe6, 0x5b, 0x2a, 0x16, 0xaa, 0xbb, 0x32, 0x58, 0xba, 0x66, 0xf0, 0x29, 0xd4,
	0x06, 0xb1, 0xe7, 0x2d, 0xe2, 0x1b, 0xef, 0x61, 0xab, 0x80, 0xe3, 0x61, 0xe0, 0x73, 0x8a, 0x0e,
	0x60, 0xcd, 0xf9, 0x44, 0xfc, 0x09, 0xcd, 0x1f, 0x4e, 0x6b, 0xb1, 0xe9, 0x37, 0x92, 0x60, 0xe7,
	0x44, 0xe3, 0xab, 0x06, 0x7a, 0xa1, 0x71, 0xa7, 0xf8, 0x3d, 0xd0, 0x9d, 0x88, 0xa6, 0x0b, 0x4a,
	0xdf, 0x74, 0xb6, 0xe0, 0xdb, 0x0b, 0x3a, 0xcd, 0x1f, 0xbc, 0x0d, 0x0a, 0x9e, 0x16, 0xae, 0xbe,
	0x4b, 0xf9, 0x1f, 0xbf, 0xcb, 0xb3, 0x23, 0x40, 0xb7, 0xf3, 0x8a, 0x2a, 0x50, 0xb2, 0xce, 0x6b,
	0xf7, 0xd0, 0x06, 0x80, 0x75, 0xd6, 0xe9, 0x1d, 0x8f, 0x8e, 0xfb, 0xef, 0x3e, 0xd4, 0xb4, 0xf4,
	0x7c, 0xde, 0xeb, 0x74, 0xb3, 0x73, 0x09, 0x6d, 0x82, 0xde, 0xeb, 0x77, 0xba, 0x83, 0x6e, 0xbf,
	0xd3, 0xed, 0x9f, 0xd6, 0xca, 0xed, 0x5f, 0xa5, 0xcc, 0xa9, 0x9a, 0x87, 0xc6, 0xa0, 0x17, 0xa2,
	0x85, 0xe6, 0x3f, 0x9c, 0xdb, 0x21, 0x6c, 0x2c, 0xe1, 0x04, 0x0d, 0x61, 0x3d, 0x4f, 0x07, 0x7a,
	0x3e, 0x17, 0x7f, 0x23, 0x44, 0x4b, 0x4d, 0xf7, 0xa0, 0x3a, 0x0b, 0x05, 0xda, 0x9d, 0x4b, 0xb8,
	0x19, 0xb2, 0x06, 0x5e, 0x16, 0xae, 0xb2, 0xf6, 0x42, 0x3b, 0xf8, 0xae, 0xc1, 0x8e, 0x4b, 0x93,
	0x79, 0xbc, 0x83, 0x5a, 0x61, 0xc1, 0x83, 0x34, 0x17, 0x03, 0xed, 0xe3, 0xcb, 0x09, 0x13, 0x38,
	0x21, 0xbe, 0x60, 0xd8, 0x09, 0x70, 0x7c, 0x69, 0xce, 0x06, 0x98, 0xdc, 0xd9, 0x25, 0x21, 0x33,
	0x27, 0x81, 0x79, 0xed, 0xdf, 0xe9, 0x47, 0x69, 0xfb, 0x64, 0x76, 0x89, 0x15, 0x32, 0xdc, 0x51,
	0x97, 0x9c, 0xca, 0xee, 0xef, 0x42, 0x77, 0x68, 0x85, 0x6c, 0xa8, 0xba, 0x43, 0xd5, 0x1d, 0x57,
	0x64, 0x1e, 0x5f, 0xfd, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x57, 0x00, 0xf7, 0xf1, 0x06, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InputSelectClient is the client API for InputSelect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InputSelectClient interface {
	// request that the input be selected
	UpdateInput(ctx context.Context, in *UpdateInputRequest, opts ...grpc.CallOption) (*Input, error)
	// get the current value of the selected input
	GetInput(ctx context.Context, in *GetInputRequest, opts ...grpc.CallOption) (*Input, error)
	// request updates to changes in the selected input
	PullInput(ctx context.Context, in *PullInputRequest, opts ...grpc.CallOption) (InputSelect_PullInputClient, error)
}

type inputSelectClient struct {
	cc *grpc.ClientConn
}

func NewInputSelectClient(cc *grpc.ClientConn) InputSelectClient {
	return &inputSelectClient{cc}
}

func (c *inputSelectClient) UpdateInput(ctx context.Context, in *UpdateInputRequest, opts ...grpc.CallOption) (*Input, error) {
	out := new(Input)
	err := c.cc.Invoke(ctx, "/smartcore.api.device.traits.InputSelect/UpdateInput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputSelectClient) GetInput(ctx context.Context, in *GetInputRequest, opts ...grpc.CallOption) (*Input, error) {
	out := new(Input)
	err := c.cc.Invoke(ctx, "/smartcore.api.device.traits.InputSelect/GetInput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *inputSelectClient) PullInput(ctx context.Context, in *PullInputRequest, opts ...grpc.CallOption) (InputSelect_PullInputClient, error) {
	stream, err := c.cc.NewStream(ctx, &_InputSelect_serviceDesc.Streams[0], "/smartcore.api.device.traits.InputSelect/PullInput", opts...)
	if err != nil {
		return nil, err
	}
	x := &inputSelectPullInputClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InputSelect_PullInputClient interface {
	Recv() (*PullInputResponse, error)
	grpc.ClientStream
}

type inputSelectPullInputClient struct {
	grpc.ClientStream
}

func (x *inputSelectPullInputClient) Recv() (*PullInputResponse, error) {
	m := new(PullInputResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InputSelectServer is the server API for InputSelect service.
type InputSelectServer interface {
	// request that the input be selected
	UpdateInput(context.Context, *UpdateInputRequest) (*Input, error)
	// get the current value of the selected input
	GetInput(context.Context, *GetInputRequest) (*Input, error)
	// request updates to changes in the selected input
	PullInput(*PullInputRequest, InputSelect_PullInputServer) error
}

// UnimplementedInputSelectServer can be embedded to have forward compatible implementations.
type UnimplementedInputSelectServer struct {
}

func (*UnimplementedInputSelectServer) UpdateInput(ctx context.Context, req *UpdateInputRequest) (*Input, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInput not implemented")
}
func (*UnimplementedInputSelectServer) GetInput(ctx context.Context, req *GetInputRequest) (*Input, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInput not implemented")
}
func (*UnimplementedInputSelectServer) PullInput(req *PullInputRequest, srv InputSelect_PullInputServer) error {
	return status.Errorf(codes.Unimplemented, "method PullInput not implemented")
}

func RegisterInputSelectServer(s *grpc.Server, srv InputSelectServer) {
	s.RegisterService(&_InputSelect_serviceDesc, srv)
}

func _InputSelect_UpdateInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputSelectServer).UpdateInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/smartcore.api.device.traits.InputSelect/UpdateInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputSelectServer).UpdateInput(ctx, req.(*UpdateInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputSelect_GetInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InputSelectServer).GetInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/smartcore.api.device.traits.InputSelect/GetInput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InputSelectServer).GetInput(ctx, req.(*GetInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InputSelect_PullInput_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PullInputRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InputSelectServer).PullInput(m, &inputSelectPullInputServer{stream})
}

type InputSelect_PullInputServer interface {
	Send(*PullInputResponse) error
	grpc.ServerStream
}

type inputSelectPullInputServer struct {
	grpc.ServerStream
}

func (x *inputSelectPullInputServer) Send(m *PullInputResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _InputSelect_serviceDesc = grpc.ServiceDesc{
	ServiceName: "smartcore.api.device.traits.InputSelect",
	HandlerType: (*InputSelectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateInput",
			Handler:    _InputSelect_UpdateInput_Handler,
		},
		{
			MethodName: "GetInput",
			Handler:    _InputSelect_GetInput_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "PullInput",
			Handler:       _InputSelect_PullInput_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "device/traits/input_select.proto",
}
